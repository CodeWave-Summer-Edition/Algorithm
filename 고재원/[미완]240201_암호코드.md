https://www.acmicpc.net/problem/2011



# 생각
1. 문제 이해
   - 5000자리 암호가 주어질 때, 나올 수 있는 해석의 가짓수를 구하라.
2. 문제 풀이

- A=1, B=2, C=3,,,이렇게 되어 있다. 1~26
- 계속 읽으면서 경우의 수로 가지를 뻗어나간다고 생각해보자.
  - 이때 생길 수 있는 문제 : 5000자리 일 경우, 
5000개를 1개 또는 2개로 자르는 모든 경우의 수를 생각 할 수 있는데, 사실 이 모든 경우의 수를 구할 때의 시간 계산을 못 하겠다.
    계속 무지성 어짜피 dp문제니 이렇게 풀면 힘들어~가 머리를 지배하고 있다...

아이디어
이거 걍 계단타기 아닌가?!

# 1차 시도 - 15% 틀림
<details>
<summary> 
  
  ## 원인
  </summary>

  해독이 안 되는 경우를 생각 못 했다....
  
  0 <- 이 녀석이 들어오면 머리가 아파진다.
  
  이 문제도 애초에 문제 생각에서 고민을 했더라면...

  

# 틀린 코드

```
import java.util.*;
import java.io.*;

class Main{

	public static void main(String[] args) throws Exception{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] inputs = br.readLine().split("");
		int[] encrypted = new int[inputs.length];
		

		for(int i=0; i<inputs.length; i++){
			encrypted[i] = Integer.parseInt(inputs[i]);
		}

		int size = inputs.length;
		int[] dp = new int[size+1];
		
		
		if(inputs.length == 1){
			System.out.println("1");
			return;
		}
		else if(inputs.length == 2){
			System.out.println(getCases(encrypted[0]*10 + encrypted[1]));
			return;
		}

		// if  size >= 3
		dp[1] = 1;
		dp[2] = getCases(encrypted[0]*10 + encrypted[1]);	
		
		for(int digit=3; digit<=size; digit++){
			dp[digit] =  dp[digit-1] + dp[digit-2]*(getCases(encrypted[digit-2]*10 + encrypted[digit-1]-1));
		}
		System.out.println(dp[size] % 1000000);
		
	}

	// if 25 -> 2,5 or 25 so 2  
	// if 56 -> only 5,6 so 1
	public static int getCases(int number){
		return number > 26
                               ? 1
                               : 2;
	}

}
```
</details>

