[문제 링크](https://www.acmicpc.net/problem/2011)
## 문제 인식
1. 해당 문자열을 해석하는 경우의 수를 구해야한다.
2. 각 알파벳은 1~26으로 해석이 된다.

## 문제 풀이
이 문제는 경우의 수를 구하는 문제다.

문자가 1~26으로 해석이 된 상태기 때문에 i번째 숫자가 한자리수로 해석이되는 경우, 두자리수의 1의자리로 해석이되는 경우, 두자리수의 10의자리로 해석이 되는 경우로 나타낼 수 있다.

이는 이전의 결과를 이용하여 현재의 문제를 풀 수 있는, 큰 문제를 작은문제를 통해 해결할 수 있는 DP문제로 해석이 가능해진다.

~~물론 경우의수를 Modular 연산을 해서 출력해라 는 경험상 98% 확률로 DP였기 때문에, 고인물들은 저것만 보고 DP문제라고 해석할 수 있지만, 문제를 통해 해결방법에 접근하며 알고리즘을 떠올리는 습관을 들여야한다.~~

따라서 dp배열을 다음과 같이 선언해주었다.
```java
/**
 * dp[i][0] = i번째 수가 한자리수로 해석되는 경우
 * dp[i][1] = i번째 수가 두자리수의 1의 자리로 해석되는 경우
 * dp[i][2] = i번째 수가 두자리수의 10의 자리로 해석되는 경우
 */
int[][] dp = new int[len][3];
```

경우의 수는 3개지로 나눴다. 각 경우마다 설명을 하겠다.

### 1. i번째 숫자가 한자리수로 해석되는 경우
A(1) ~ I(9)로 해석이 되는 숫자인 경우를 의미한다. 이는 독단적으로 해석이되기떄문에, i-1번째까지 해석이 완료된 경우들의 합이 된다.

_ _ _ _ _ 5 라고 해보자. 5번째 사용된 5(E) 라는 숫자는, 4번째까지 완성된 문자열 뒤에 5(E)를 붙인 경우가 된다. 

따라서 `i-1번째 숫자가 한자리로 해석이 되는 숫자(A(1)~I(9))인 경우의 뒤에 붙여도, 두자리수의 1의자리로 해석이되는 숫자인 경우의 뒤에 붙여도 모두 성립한다.`
```java
/**
 * i번째 자리가 한자리수로 해석되는 경우
 * 이 경우는 i-1번째까지 해석이 완성이 된 경우에 해당 경우의 수를 더해주면됨
 * 따라서 (이전 자리의 수가 한자리수로 해석된 경우 + 두자리수의 1의자리로 해석된 경우 ) 이 된다.
 * 이 경우는, 0이 되면 안됨
 */
if(numbers[i] != '0') {
    dp[i][0] = (dp[i - 1][0] + dp[i - 1][1]) % MOD;
}
```

### 2. i번째 숫자가 두자리수의 1의 자리로 해석이되는 경우
두자리수의 1의자리로 해석이 되는 경우는 0~9까지 모두 나와도 가능하다. 다만 이 숫자의 앞자리가 1또는 2가 오는 경우에만 가능하다.

예를들어 _ _ _ _ 5 가 있다고 해보자. 5 앞에 1이 붙으면 15로 해석이될 수 있고, 2가 붙으면 25로 해석이 가능하다. 1또는 2가 아닌 숫자로는 i번째 숫자를 두자리수로 해석이 불가능하게 된다.(ex 95 = 해석불가)

또한 앞자리가 1인 경우에는, i번째 숫자가 0~9 모두 가능하지만, 2인 경우에는 0~6 까지만 가능하게된다. (해석이 26이 최대이기 때문이다)

이렇게 된다면, `앞자리수가 두자리수의 10의자리로 해석이 되는 경우의수를 그대로 따라가고, 따라갈 수 없다면 i번째를 두자리수의 1의자리로 해석이 불가능하게되므로 경우의수는 0이된다.`
```java
/**
 * i번째 자리가 두자리수의 1의자리로 해석되는 경우
 * 이 경우는 i-1번째 자리가 두자리수의 10의자리로 해석되는 경우의 연장선
 * 따라서 (이전 자리의 수가 두자리수의 10의자리로 해석된 경우의 경우의수) 가 된다.
 * 하지만, 바로 이전의 자리수가 1또는 2일때만 가능하고, 2일때는 해당 자리가 무조건 0~6 사이여야 한다.
 */
if (numbers[i - 1] == '1' || (numbers[i - 1] == '2' && (numbers[i] >= '0' && numbers[i] <= '6'))) {
    dp[i][1] = (dp[i - 1][2]) % MOD;
} else {
    dp[i][1] = 0;
}
```
### 3. i번째 숫자가 두자리수의 10의 자리로 해석이되는 경우
이 경우는 간단하다. i가 1또는 2가 된다면 해석이 되는 경우라고 본다.

따라서 `i-1번째 알파벳이 한자리로 해석이 되는 숫자(A(1)~I(9))인 경우의 뒤에 붙여도, 두자리수의 1의자리로 해석이되는 숫자인인 경우의 뒤에 붙여도 모두 성립한다.`
```java
/**
 * i번째 자리가 두자리수의 10의 자리로 해석되는 경우
 * 이 경우는 i-1번째까지 해석이 완성이 된 경우에 해당 경우의수를 더해주면됨
 * 따라서 (이전 자리의 수가 한자리수로 해석된 경우 + 두자리수의 1의자리로 해석된 경우 ) 이 된다.
 * 이 경우는, 해당 자리가 1 or 2인 경우만 가능하다.
 */
if (numbers[i] == '1' || numbers[i] == '2') {
    dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % MOD;
}
```

### 최종정답
문자열의 끝까지 왔다면 모든 경우의 수를 구했을 것이다. 이때, 마지막 숫자가 두자리수의 10의자리로 해석이되는 숫자로 해석된 경우의수는 아직 완성되지 않은 경우이므로, 이 경우를 뺀 (dp[len-1][0] + dp[len-1][1])이 정답이된다. 

## 코드 (O(N))
```java
import java.io.*;

public class Main {
    static final int MOD = 1_000_000;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        char[] numbers = br.readLine().toCharArray();
        int len = numbers.length;
        int answer = 0;
        if (numbers[0] != '0') {//0번째 자리에 0이 올 수 없음
            /**
             * dp[i][0] = i번째 수가 한자리수로 해석되는 경우
             * dp[i][1] = i번째 수가 두자리수의 1의 자리로 해석되는 경우
             * dp[i][2] = i번째 수가 두자리수의 10의 자리로 해석되는 경우
             */
            int[][] dp = new int[len][3];
            dp[0][0] = 1;//0번째 자리가 한자리수로 무조건 해석 가능
            dp[0][1] = 0;//0번째 자리는 두자리수의 1의자리로 해석 불가.
            dp[0][2] = (numbers[0] <= '2' ? 1 : 0);//0번째 자리가 1 또는 2인 경우는 두자리수의 10의 자리로 해석 가능
            for (int i = 1; i < numbers.length; i++) {
                /**
                 * i번째 자리가 한자리수로 해석되는 경우
                 * 이 경우는 i-1번째까지 해석이 완성이 된 경우에 해당 경우의 수를 더해주면됨
                 * 따라서 (이전 자리의 수가 한자리수로 해석된 경우 + 두자리수의 1의자리로 해석된 경우 ) 이 된다.
                 * 이 경우는, 0이 되면 안됨
                 */
                if(numbers[i] != '0') {
                    dp[i][0] = (dp[i - 1][0] + dp[i - 1][1]) % MOD;
                }
                /**
                 * i번째 자리가 두자리수의 1의자리로 해석되는 경우
                 * 이 경우는 i-1번째 자리가 두자리수의 10의자리로 해석되는 경우의 연장선
                 * 따라서 (이전 자리의 수가 두자리수의 10의자리로 해석된 경우의 경우의수) 가 된다.
                 * 하지만, 바로 이전의 자리수가 1또는 2일때만 가능하고, 2일때는 해당 자리가 무조건 0~6 사이여야 한다.
                 */
                if (numbers[i - 1] == '1' || (numbers[i - 1] == '2' && (numbers[i] >= '0' && numbers[i] <= '6'))) {
                    dp[i][1] = (dp[i - 1][2]) % MOD;
                }

                /**
                 * i번째 자리가 두자리수의 10의 자리로 해석되는 경우
                 * 이 경우는 i-1번째까지 해석이 완성이 된 경우에 해당 경우의수를 더해주면됨
                 * 따라서 (이전 자리의 수가 한자리수로 해석된 경우 + 두자리수의 1의자리로 해석된 경우 ) 이 된다.
                 * 이 경우는, 해당 자리가 1 or 2인 경우만 가능하다.
                 */
                if (numbers[i] == '1' || numbers[i] == '2') {
                    dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % MOD;
                }
            }
            /**
             * 정답은 len까지 완성된 경우의수를 더해주면됨
             */
            answer = (dp[len - 1][0] + dp[len - 1][1]) % MOD;
        }

        bw.write(Integer.toString(answer % MOD));
        br.close();
        bw.close();
    }
}

```
